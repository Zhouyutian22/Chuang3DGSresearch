## **初始化场景**：

将场景表示为一组3D高斯点。每个高斯点包含位置（均值）、协方差矩阵（决定扩散方向和形状）以及不透明度参数。场景初始化时，这些高斯点通常从SfM（Structure-from-Motion）生成的稀疏点云开始，进一步通过优化调整位置和分布。

## ```forward```前向渲染

**瓦片分割**：将屏幕划分为16×16像素的瓦片（tiles）。这种瓦片划分确保每个小块可以在 CUDA 的线程块中并行处理并减少计算量，尤其是在大场景中。

**视锥剔除**：通过视锥体剔除算法筛选出在每个瓦片视锥范围内的高斯点。这样能够避免对不可见的高斯点进行计算，提高渲染效率。

**深度排序（Radix排序）**：使用GPU上的基数排序算法对每个瓦片内的高斯点进行深度排序。排序后，高斯点按从近到远的顺序排列，有利于实现近似的α混合（𝛼-blending），即将更近的点覆盖远处的点，实现正确的透明度叠加。

**栅格化与混合**：对每个瓦片内的高斯点进行栅格化处理，将 3D 高斯点投影到 2D 屏幕空间，并进行颜色和透明度的叠加（α混合）。这一过程会将排序后的高斯点逐个叠加在像素上，形成最终的颜色。混合过程是可微的，因此在优化中可以进行反向传播。

**近似饱和停止**：在渲染的过程中，`forward` 会检测每个像素的透明度值，当透明度接近 1 时，该像素的累积过程停止，减少计算负担。这一停止条件使得渲染在达到视觉要求后不再计算额外的透明度。

## `backward` 反向传播

`backward` 函数用于**优化阶段的反向传播**，即根据损失计算各个高斯点的梯度，并更新它们的参数。具体来说，`backward` 具有以下的流程：

* **加载前向缓存的数据**：在反向传播时，需要从 从 `forward` 函数存储的分块信息中加载前向传播过程中存储的小块和像素信息。这些数据用于定位每个小块中高斯点的梯度贡献，且无需重新分块和排序。

* **并行计算每个参数的梯度**：根据损失对每个像素的影响，计算参数的梯度，包括位置、协方差、颜色和透明度等。通过这些梯度，优化算法可以更新高斯点的参数，以使渲染结果更符合优化目标（如损失函数最小化）。同时在每个小块内，也可以并行地计算每个像素的梯度贡献，使得反向传播的计算效率得到提升。

* **输出梯度**：最终，将每个参数的梯度结果写入到指定的输出缓冲区中，这些梯度将用于更新高斯点的参数，以优化渲染效果。

## 图像输出

最后，经过上述步骤得到的颜色和深度信息合成为最终的图像输出。这种方法能够实现高效的实时渲染，并提供视觉上逼真的效果。